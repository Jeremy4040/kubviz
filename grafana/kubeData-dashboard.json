{
  "annotations": {
    "list": [
      {
        "builtIn": 1,
        "datasource": "-- Grafana --",
        "enable": true,
        "hide": true,
        "iconColor": "rgba(0, 211, 255, 1)",
        "name": "Annotations & Alerts",
        "target": {
          "limit": 100,
          "matchAny": false,
          "tags": [],
          "type": "dashboard"
        },
        "type": "dashboard"
      }
    ]
  },
  "editable": true,
  "fiscalYearStartMonth": 0,
  "graphTooltip": 0,
  "id": 56,
  "links": [],
  "liveNow": false,
  "panels": [
    {
      "datasource": {
        "type": "vertamedia-clickhouse-datasource",
        "uid": "vertamedia-clickhouse-datasource"
      },
      "gridPos": {
        "h": 9,
        "w": 24,
        "x": 0,
        "y": 0
      },
      "id": 11,
      "options": {
        "baidu": {
          "callback": "bmapReady",
          "key": ""
        },
        "editor": {
          "format": "auto",
          "height": 600
        },
        "editorMode": "code",
        "gaode": {
          "key": "",
          "plugin": "AMap.Scale,AMap.ToolBar"
        },
        "getOption": "let option; // Initialize the option variable\n\nif (typeof context.panel.data === 'undefined' || !context.panel.data.series || !context.panel.data.series[0] || !context.panel.data.series[0].fields) {\n  // Data is not available or doesn't have the expected structure\n  option = {\n    title: {\n      text: 'Data not available',\n      textStyle: {\n        fontSize: 24,\n        fontWeight: 'bold',\n      },\n      left: 'center',\n      top: 'middle',\n    },\n  };\n} else {\n  // Extract data from your JSON as before\n  const clusterNames = context.panel.data.series[0].fields[0].values;\n  const namespaces = context.panel.data.series[0].fields[1].values;\n  const reasons = context.panel.data.series[0].fields[2].values;\n  const pods = context.panel.data.series[0].fields[3].values;\n\n  // Create a hierarchical structure from the data without a root node\n  const hierarchy = {\n    name: 'root', // Use 'root' as a placeholder\n    children: [],\n  };\n\n  const seenClusterNames = new Set();\n  const seenNamespaces = new Set();\n\n  for (let i = 0; i < clusterNames.length; i++) {\n    const clusterName = clusterNames[i];\n    const namespace = namespaces[i];\n    const reason = reasons[i];\n    const pod = pods[i];\n\n    if (!seenClusterNames.has(clusterName)) {\n      seenClusterNames.add(clusterName);\n      const clusterNode = { name: clusterName, children: [] };\n      hierarchy.children.push(clusterNode);\n      seenNamespaces.clear(); // Reset seenNamespaces for each cluster\n    }\n\n    const clusterNode = hierarchy.children.find((node) => node.name === clusterName);\n\n    if (!seenNamespaces.has(namespace)) {\n      seenNamespaces.add(namespace);\n      const namespaceNode = { name: namespace, children: [] };\n      clusterNode.children.push(namespaceNode);\n    }\n\n    const namespaceNode = clusterNode.children.find((node) => node.name === namespace);\n    const reasonNode = { name: reason, children: [{ name: `Count: ${pod}` }] };\n    namespaceNode.children.push(reasonNode);\n  }\n\n  // Create the tree chart using ECharts\n  option = {\n    tooltip: {\n      trigger: 'item',\n      triggerOn: 'mousemove',\n      formatter: function (params) {\n        const node = params.data;\n        let tooltip = '';\n        if (node.column) {\n          tooltip += `${node.column}: ${node.name}`;\n        } else {\n          tooltip += node.name;\n        }\n        return tooltip;\n      },\n    },\n    series: [\n      {\n        type: 'tree',\n        data: hierarchy.children, // Use the children directly\n        top: '1%',\n        left: '7%',\n        bottom: '1%',\n        right: '20%',\n        symbolSize: 7,\n        label: {\n          position: 'left',\n          verticalAlign: 'middle',\n          align: 'centre',\n          fontSize: 15, // Increase the text size for regular nodes\n          fontWeight: 'bold', // Set the font weight to bold\n        },\n        leaves: {\n          label: {\n            position: 'right',\n            verticalAlign: 'middle',\n            align: 'left',\n            fontSize: 15, // Increase the text size for leaves\n            fontWeight: 'bold', // Set the font weight to bold\n          },\n        },\n        emphasis: {\n          focus: 'descendant',\n        },\n        expandAndCollapse: true,\n        animationDuration: 550,\n        animationDurationUpdate: 750,\n      },\n    ],\n  };\n}\n\nreturn option;",
        "google": {
          "callback": "gmapReady",
          "key": ""
        },
        "map": "none",
        "renderer": "canvas",
        "themeEditor": {
          "config": "{}",
          "height": 400,
          "name": "default"
        },
        "visualEditor": {
          "code": "return {\n  dataset: context.editor.dataset,\n  series: context.editor.series,\n  xAxis: {\n    type: 'time',\n  },\n  yAxis: {\n    type: 'value',\n    min: 'dataMin',\n  },\n}\n",
          "dataset": [],
          "series": []
        }
      },
      "pluginVersion": "6.0.0",
      "targets": [
        {
          "datasource": {
            "type": "vertamedia-clickhouse-datasource",
            "uid": "vertamedia-clickhouse-datasource"
          },
          "dateTimeType": "DATETIME",
          "extrapolate": true,
          "format": "table",
          "formattedQuery": "SELECT $timeSeries as t, count() FROM $table WHERE $timeFilter GROUP BY t ORDER BY t",
          "intervalFactor": 1,
          "query": "SELECT ClusterName, Namespace, Reason, count(*) AS Pods\nFROM default.events\nWHERE $timeFilterByColumn(EventTime) AND Kind IN ('Pod') AND ClusterName IN ($clusterName) AND Namespace IN ($namespace) AND Reason IN ($reason)\nGROUP BY ClusterName, Namespace, Reason",
          "rawQuery": "SELECT ClusterName, Namespace, Reason, count(*) AS Pods\nFROM default.events\nWHERE EventTime >= toDateTime(1702949773) AND EventTime <= toDateTime(1702992973) AND Kind IN ('Pod') AND ClusterName IN ('capten-controlplane','kubviz','dev') AND Namespace IN ('argo-cd','crossplane','default','kubescape-prometheus','kubviz','kyverno','linkerd','observability','openebs-cstor','testkube','capten','falco','tekton','crossplane-system','test5','tek','tekton-pipelines','harbor','tekton-pipelines-resolvers','quality-trace','kube-system','cert-manager','emojivoto','local-path-storage','test-linkerd','external-secrets','policy-reporter','velero','tracetest') AND Reason IN ('BackOff','FailedMount','Unhealthy','SyncPackage','SelectComposition','SyncFailed','CannotUpdateExternalResource','RenderCRD','OfferClaim','EstablishComposite','SuccessfulCreate','InjectionSkipped','Scheduled','Pulled','Created','Started','Completed','SawCompletedJob','BindClusterRole','ApplyClusterRoles','CannotInitializeManagedResource','InstallPackageRevision','CreatedUsers','CreatedSuperuser','ApplyRoles','Synced','Killing','Init','ExternalProvisioning','Provisioning','Running','FailedScheduling','ProvisioningSucceeded','ScalingReplicaSet','Pending','Updated','FailUpdate','Degraded','Pulling','Healthy','Succeeded','IssuedLeafCertificate','Failed','Offline','EvictionThresholdMet','NodeHasDiskPressure','NodeHasNoDiskPressure','FreeDiskSpaceFailed','CreateCertificate','Issuing','Generated','Requested','cert-manager.io','OrderCreated','OrderPending','Presented','DomainVerified','Complete','CertificateIssued','SuccessfulDelete','ConfigureCompositeResource','BindCompositeResource','ImageGCFailed','ClaimLost','Evicted','RecreatingFailedPod','LeaderElection','InternalError','Reused','IssuerUpdated','OperationStarted','ResourceUpdated','OperationCompleted','MultiplePodDisruptionBudgets','MissingJob','InvalidOrder','TaintManagerEviction','SystemOOM','FailedKillPod','NodeHasSufficientMemory','NodeHasSufficientPID','NodeNotReady','FailedPreStopHook','NodeReady','Pool Imported','AlreadyPresent','StartingCassandra','UpdateCompleted','LabeledPodAsSeed','StartedCassandra','ComposeResources','UpdatedExternalResource','CannotDeleteExternalResource','DeletedExternalResource','ReconcileInProgress','ReconcileCompleted','ReconcileStarted','ProgressHostsCompleted','ReconcileFailed','UnlabeledPodAsSeed','CannotObserveExternalResource','DeletingStuckPod','DeleteCompositeResource','ResourceDeleted','PublishConnectionSecret','UnpackPackage','ResolveDependencies','ExceededGracePeriod','ProvisioningFailed','CannotCreateExternalResource','FailStatusSync','FailCreate','CannotUpdateManagedResource','CannotResolveResourceReferences','CreatedExternalResource','FailedSync','RegisteredNode','OwnerRefInvalidNamespace','NoPods','DeadlineExceeded','Create','FailedGetScale','NodeAllocatableEnforced','Starting','LintPackage','SandboxChanged','WaitForFirstConsumer','FailedGetResourceMetric','FailedCreate','Injected','Resizing','ExternalExpanding','VolumeResizeFailed','VolumeResizeSuccessful','FileSystemResizeRequired','FileSystemResizeSuccessful','CreatedResource','FailedToUpdateEndpoint','UpdateCertificate','FailedUpdateStatus','UpdateFailed','FailedComputeMetricsReplicas','FailedToCreateEndpoint','FailedAttachVolume','FailedToUpdateEndpointSlices','FailedDelete','Pool Expansion','Error')\nGROUP BY ClusterName, Namespace, Reason",
          "refId": "A",
          "round": "0s",
          "skip_comments": true
        }
      ],
      "title": "Pod  Scenario Counts by Cluster, Namespace",
      "type": "volkovlabs-echarts-panel"
    },
    {
      "datasource": {
        "type": "vertamedia-clickhouse-datasource",
        "uid": "vertamedia-clickhouse-datasource"
      },
      "gridPos": {
        "h": 10,
        "w": 24,
        "x": 0,
        "y": 9
      },
      "id": 12,
      "options": {
        "baidu": {
          "callback": "bmapReady",
          "key": ""
        },
        "editor": {
          "format": "auto",
          "height": 600
        },
        "editorMode": "code",
        "gaode": {
          "key": "",
          "plugin": "AMap.Scale,AMap.ToolBar"
        },
        "getOption": "let option; // Initialize the option variable\n\nif (typeof context.panel.data === 'undefined' || !context.panel.data.series || !context.panel.data.series[0] || !context.panel.data.series[0].fields) {\n  // Data is not available or doesn't have the expected structure\n  option = {\n    title: {\n      text: 'Data not available',\n      textStyle: {\n        fontSize: 24,\n        fontWeight: 'bold',\n      },\n      left: 'center',\n      top: 'middle',\n    },\n  };\n} else {\n  // Extract data from your JSON as before\n  const reasons = context.panel.data.series[0].fields[0].values;\n  const counts = context.panel.data.series[0].fields[1].values;\n\n  // Check if reasons and counts are defined and not empty\n  if (!reasons || !counts || reasons.length === 0 || counts.length === 0) {\n    // Display a message when no data is available\n    option = {\n      title: {\n        text: 'Data not available',\n        textStyle: {\n          fontSize: 24,\n          fontWeight: 'bold',\n        },\n        left: 'center',\n        top: 'middle',\n      },\n    };\n  } else {\n    // Data is available, proceed with the chart creation\n    // Create an array of data items, each containing name and value\n    const seriesData = reasons.map((reason, index) => ({\n      name: reason,\n      value: counts[index],\n    }));\n\n    // Define a custom color for the bars\n    const customColor = 'rgb(0, 123, 255)'; // Change this to your desired color\n\n    // Apache ECharts option\n    option = {\n      xAxis: {\n        type: 'category',\n        data: reasons, // Use the reasons directly for xAxis data\n        axisLabel: {\n          interval: 0, // Display all labels on the xAxis\n        },\n      },\n      yAxis: {\n        type: 'value',\n      },\n      legend: {\n        data: ['Pods'], // Legend name\n        left: 'left',   // Position the legend on the left side\n        bottom: 'bottom', // Position the legend at the bottom\n      },\n      series: [\n        {\n          name: 'Pods',  // Series name for the legend\n          data: seriesData,\n          type: 'bar',\n          label: {\n            show: true,\n            position: 'top',\n            formatter: '{c}',\n          },\n          itemStyle: {\n            barBorderRadius: [5, 5, 0, 0], // Adjust the values to control the curvature\n            color: customColor, // Set the custom color for the bars\n          },\n        },\n      ],\n    };\n  }\n}\n\nreturn option;",
        "google": {
          "callback": "gmapReady",
          "key": ""
        },
        "map": "none",
        "renderer": "canvas",
        "themeEditor": {
          "config": "{}",
          "height": 400,
          "name": "default"
        },
        "visualEditor": {
          "code": "return {\n  dataset: context.editor.dataset,\n  series: context.editor.series,\n  xAxis: {\n    type: 'time',\n  },\n  yAxis: {\n    type: 'value',\n    min: 'dataMin',\n  },\n}\n",
          "dataset": [],
          "series": []
        }
      },
      "pluginVersion": "6.0.0",
      "targets": [
        {
          "datasource": {
            "type": "vertamedia-clickhouse-datasource",
            "uid": "vertamedia-clickhouse-datasource"
          },
          "dateTimeType": "DATETIME",
          "extrapolate": true,
          "format": "table",
          "formattedQuery": "SELECT $timeSeries as t, count() FROM $table WHERE $timeFilter GROUP BY t ORDER BY t",
          "intervalFactor": 1,
          "query": "SELECT Reason, count(Reason) AS Pods\nFROM default.events\nWHERE $timeFilterByColumn(EventTime) AND Kind IN ('Pod') AND ClusterName IN ($clusterName) AND Namespace In ($namespace)\nGROUP BY Reason",
          "rawQuery": "SELECT Reason, count(Reason) AS Pods\nFROM default.events\nWHERE EventTime >= toDateTime(1702949951) AND EventTime <= toDateTime(1702993151) AND Kind IN ('Pod') AND ClusterName IN ('capten-controlplane','kubviz','dev') AND Namespace In ('quality-trace','crossplane-system','observability','default','testkube','openebs-cstor','kyverno','kubescape-prometheus','tekton-pipelines','capten','tek','test-linkerd','linkerd','argo-cd','tracetest','emojivoto','falco','kube-system','crossplane','kubviz','tekton','test5','harbor','tekton-pipelines-resolvers','cert-manager','local-path-storage','external-secrets','policy-reporter','velero')\nGROUP BY Reason",
          "refId": "A",
          "round": "0s",
          "skip_comments": true
        }
      ],
      "title": "Total Pod Counts by Reason",
      "type": "volkovlabs-echarts-panel"
    },
    {
      "datasource": {
        "type": "vertamedia-clickhouse-datasource",
        "uid": "vertamedia-clickhouse-datasource"
      },
      "gridPos": {
        "h": 14,
        "w": 24,
        "x": 0,
        "y": 19
      },
      "id": 6,
      "options": {
        "baidu": {
          "callback": "bmapReady",
          "key": ""
        },
        "editor": {
          "format": "auto",
          "height": 600
        },
        "editorMode": "code",
        "gaode": {
          "key": "",
          "plugin": "AMap.Scale,AMap.ToolBar"
        },
        "getOption": "let option; // Initialize the option variable\n\nif (typeof context.panel.data === 'undefined' || !context.panel.data.series || !context.panel.data.series[0] || !context.panel.data.series[0].fields) {\n  // Data is not available or doesn't have the expected structure\n  option = {\n    title: {\n      text: 'Data not available',\n      textStyle: {\n        fontSize: 24,\n        fontWeight: 'bold',\n      },\n      left: 'center',\n      top: 'middle',\n    },\n  };\n} else {\n\n  // Define the data from your JSON\n  const clusterNames = context.panel.data.series[0].fields[0].values;\n  const kinds = context.panel.data.series[0].fields[1].values;\n  const reasons = context.panel.data.series[0].fields[2].values;\n  const counts = context.panel.data.series[0].fields[3].values;\n\n  // Create the Sankey chart configuration\n  option = {\n    series: {\n      type: 'sankey',\n      layout: 'none',\n      emphasis: {\n        focus: 'adjacency',\n      },\n      data: [],\n      links: [],\n    },\n    tooltip: {\n      trigger: 'item',\n      formatter: (params) => {\n        if (params.dataType === 'node') {\n          return params.name;\n        }\n        if (params.dataType === 'edge') {\n          return `Count: ${counts[params.dataIndex]}`; // Display count values\n        }\n        return '';\n      },\n    },\n  };\n\n  // Create nodes for ClusterName, Kind, and Reason\n  const uniqueClusterNames = Array.from(new Set(clusterNames));\n  const uniqueKinds = Array.from(new Set(kinds));\n  const uniqueReasons = Array.from(new Set(reasons));\n\n  uniqueClusterNames.forEach((name, index) => {\n    option.series.data.push({\n      name: name,\n    });\n  });\n\n  uniqueKinds.forEach((name, index) => {\n    option.series.data.push({\n      name: name,\n    });\n  });\n\n  uniqueReasons.forEach((name, index) => {\n    option.series.data.push({\n      name: name,\n    });\n  });\n\n\n  // Create links from Kind to Reason\n  kinds.forEach((kind, index) => {\n    const sourceIndex = uniqueClusterNames.length + uniqueKinds.indexOf(kind);\n    const targetIndex = 1 * uniqueClusterNames.length + uniqueKinds.length + uniqueReasons.indexOf(reasons[index]);\n    option.series.links.push({\n      source: sourceIndex,\n      target: targetIndex,\n      value: counts[index], // Use count values\n    });\n  });\n\n  // Create links from ClusterName to Kind\n  clusterNames.forEach((clusterName, index) => {\n    const sourceIndex = uniqueClusterNames.indexOf(clusterName);\n    const targetIndex = uniqueClusterNames.length + uniqueKinds.indexOf(kinds[index]);\n    option.series.links.push({\n      source: sourceIndex,\n      target: targetIndex,\n      value: 1,\n    });\n  });\n}\n\n\nreturn option;\n// Render the chart\nmyChart.setOption(option);",
        "google": {
          "callback": "gmapReady",
          "key": ""
        },
        "map": "none",
        "renderer": "canvas",
        "themeEditor": {
          "config": "{}",
          "height": 400,
          "name": "default"
        },
        "visualEditor": {
          "code": "return {\n  dataset: context.editor.dataset,\n  series: context.editor.series,\n  xAxis: {\n    type: 'time',\n  },\n  yAxis: {\n    type: 'value',\n    min: 'dataMin',\n  },\n}\n",
          "dataset": [],
          "series": []
        }
      },
      "pluginVersion": "6.0.0",
      "targets": [
        {
          "datasource": {
            "type": "vertamedia-clickhouse-datasource",
            "uid": "vertamedia-clickhouse-datasource"
          },
          "dateTimeType": "DATETIME",
          "extrapolate": true,
          "format": "table",
          "formattedQuery": "SELECT $timeSeries as t, count() FROM $table WHERE $timeFilter GROUP BY t ORDER BY t",
          "intervalFactor": 1,
          "query": "SELECT ClusterName, Kind, Reason, COUNT(*) as Count\nFROM default.events\nWHERE $timeFilterByColumn(EventTime) AND ClusterName IN ($clusterName) AND Kind IN ('Pod', 'Node', 'Deployment')\nGROUP BY ClusterName, Kind, Reason\nORDER BY Count DESC",
          "rawQuery": "SELECT ClusterName, Kind, Reason, COUNT(*) as Count\nFROM default.events\nWHERE EventTime >= toDateTime(1698927439) AND EventTime <= toDateTime(1698927739) AND ClusterName IN ('beta-cluster') AND Kind IN ('Pod', 'Node', 'Deployment')\nGROUP BY ClusterName, Kind, Reason\nORDER BY Count DESC",
          "refId": "A",
          "round": "0s",
          "skip_comments": true
        }
      ],
      "title": "K8s metrics status",
      "type": "volkovlabs-echarts-panel"
    },
    {
      "datasource": {
        "type": "vertamedia-clickhouse-datasource",
        "uid": "vertamedia-clickhouse-datasource"
      },
      "gridPos": {
        "h": 8,
        "w": 12,
        "x": 0,
        "y": 33
      },
      "id": 8,
      "options": {
        "baidu": {
          "callback": "bmapReady",
          "key": ""
        },
        "editor": {
          "format": "auto",
          "height": 600
        },
        "editorMode": "code",
        "gaode": {
          "key": "",
          "plugin": "AMap.Scale,AMap.ToolBar"
        },
        "getOption": "let option; // Initialize the option variable\n\nif (typeof context.panel.data === 'undefined' || !context.panel.data.series || !context.panel.data.series[0] || !context.panel.data.series[0].fields) {\n  // Data is not available or doesn't have the expected structure\n  option = {\n    title: {\n      text: 'Data not available',\n      textStyle: {\n        fontSize: 24,\n        fontWeight: 'bold',\n      },\n      left: 'center',\n      top: 'middle',\n    },\n  };\n} else {\n\n  // Define the data from your JSON\n  const clusterNames = context.panel.data.series[0].fields[0].values;\n  const kinds = context.panel.data.series[0].fields[1].values;\n  const reasons = context.panel.data.series[0].fields[2].values;\n  const counts = context.panel.data.series[0].fields[3].values;\n\n  // Create the Sankey chart configuration\n  option = {\n    series: {\n      type: 'sankey',\n      layout: 'none',\n      emphasis: {\n        focus: 'adjacency',\n      },\n      data: [],\n      links: [],\n    },\n    tooltip: {\n      trigger: 'item',\n      formatter: (params) => {\n        if (params.dataType === 'node') {\n          return params.name;\n        }\n        if (params.dataType === 'edge') {\n          return `Count: ${counts[params.dataIndex]}`; // Display count values\n        }\n        return '';\n      },\n    },\n  };\n\n  // Create nodes for ClusterName, Kind, and Reason\n  const uniqueClusterNames = Array.from(new Set(clusterNames));\n  const uniqueKinds = Array.from(new Set(kinds));\n  const uniqueReasons = Array.from(new Set(reasons));\n\n  uniqueClusterNames.forEach((name, index) => {\n    option.series.data.push({\n      name: name,\n    });\n  });\n\n  uniqueKinds.forEach((name, index) => {\n    option.series.data.push({\n      name: name,\n    });\n  });\n\n  uniqueReasons.forEach((name, index) => {\n    option.series.data.push({\n      name: name,\n    });\n  });\n\n\n  // Create links from Kind to Reason\n  kinds.forEach((kind, index) => {\n    const sourceIndex = uniqueClusterNames.length + uniqueKinds.indexOf(kind);\n    const targetIndex = 1 * uniqueClusterNames.length + uniqueKinds.length + uniqueReasons.indexOf(reasons[index]);\n    option.series.links.push({\n      source: sourceIndex,\n      target: targetIndex,\n      value: counts[index], // Use count values\n    });\n  });\n\n  // Create links from ClusterName to Kind\n  clusterNames.forEach((clusterName, index) => {\n    const sourceIndex = uniqueClusterNames.indexOf(clusterName);\n    const targetIndex = uniqueClusterNames.length + uniqueKinds.indexOf(kinds[index]);\n    option.series.links.push({\n      source: sourceIndex,\n      target: targetIndex,\n      value: 1,\n    });\n  });\n}\n\n\n\nreturn option;\n// Render the chart\nmyChart.setOption(option);",
        "google": {
          "callback": "gmapReady",
          "key": ""
        },
        "map": "none",
        "renderer": "canvas",
        "themeEditor": {
          "config": "{}",
          "height": 400,
          "name": "default"
        },
        "visualEditor": {
          "code": "return {\n  dataset: context.editor.dataset,\n  series: context.editor.series,\n  xAxis: {\n    type: 'time',\n  },\n  yAxis: {\n    type: 'value',\n    min: 'dataMin',\n  },\n}\n",
          "dataset": [],
          "series": []
        }
      },
      "pluginVersion": "6.0.0",
      "targets": [
        {
          "datasource": {
            "type": "vertamedia-clickhouse-datasource",
            "uid": "vertamedia-clickhouse-datasource"
          },
          "dateTimeType": "DATETIME",
          "extrapolate": true,
          "format": "table",
          "formattedQuery": "SELECT $timeSeries as t, count() FROM $table WHERE $timeFilter GROUP BY t ORDER BY t",
          "intervalFactor": 1,
          "query": "SELECT ClusterName, Kind, Reason, COUNT(*) as Count\nFROM default.events\nWHERE $timeFilterByColumn(EventTime) AND ClusterName IN ($clusterName) AND Kind IN ('Service')\nGROUP BY ClusterName, Kind, Reason\nORDER BY Count DESC",
          "rawQuery": "SELECT ClusterName, Kind, Reason, COUNT(*) as Count\nFROM default.events\nWHERE EventTime >= toDateTime(1698931712) AND EventTime <= toDateTime(1698932012) AND ClusterName IN ('beta-cluster') AND Kind IN ('Service')\nGROUP BY ClusterName, Kind, Reason\nORDER BY Count DESC",
          "refId": "A",
          "round": "0s",
          "skip_comments": true
        }
      ],
      "title": "Service Events by Cluster and Reason",
      "type": "volkovlabs-echarts-panel"
    },
    {
      "datasource": {
        "type": "vertamedia-clickhouse-datasource",
        "uid": "vertamedia-clickhouse-datasource"
      },
      "gridPos": {
        "h": 8,
        "w": 12,
        "x": 12,
        "y": 33
      },
      "id": 9,
      "options": {
        "baidu": {
          "callback": "bmapReady",
          "key": ""
        },
        "editor": {
          "format": "auto",
          "height": 600
        },
        "editorMode": "code",
        "gaode": {
          "key": "",
          "plugin": "AMap.Scale,AMap.ToolBar"
        },
        "getOption": "let option; // Initialize the option variable\n\nif (typeof context.panel.data === 'undefined' || !context.panel.data.series || !context.panel.data.series[0] || !context.panel.data.series[0].fields) {\n  // Data is not available or doesn't have the expected structure\n  option = {\n    title: {\n      text: 'Data not available',\n      textStyle: {\n        fontSize: 24,\n        fontWeight: 'bold',\n      },\n      left: 'center',\n      top: 'middle',\n    },\n  };\n} else {\n\n  // Define the data from your JSON\n  const clusterNames = context.panel.data.series[0].fields[0].values;\n  const kinds = context.panel.data.series[0].fields[1].values;\n  const reasons = context.panel.data.series[0].fields[2].values;\n  const counts = context.panel.data.series[0].fields[3].values;\n\n  // Create the Sankey chart configuration\n  option = {\n    series: {\n      type: 'sankey',\n      layout: 'none',\n      emphasis: {\n        focus: 'adjacency',\n      },\n      data: [],\n      links: [],\n    },\n    tooltip: {\n      trigger: 'item',\n      formatter: (params) => {\n        if (params.dataType === 'node') {\n          return params.name;\n        }\n        if (params.dataType === 'edge') {\n          return `Count: ${counts[params.dataIndex]}`; // Display count values\n        }\n        return '';\n      },\n    },\n  };\n\n  // Create nodes for ClusterName, Kind, and Reason\n  const uniqueClusterNames = Array.from(new Set(clusterNames));\n  const uniqueKinds = Array.from(new Set(kinds));\n  const uniqueReasons = Array.from(new Set(reasons));\n\n  uniqueClusterNames.forEach((name, index) => {\n    option.series.data.push({\n      name: name,\n    });\n  });\n\n  uniqueKinds.forEach((name, index) => {\n    option.series.data.push({\n      name: name,\n    });\n  });\n\n  uniqueReasons.forEach((name, index) => {\n    option.series.data.push({\n      name: name,\n    });\n  });\n\n\n  // Create links from Kind to Reason\n  kinds.forEach((kind, index) => {\n    const sourceIndex = uniqueClusterNames.length + uniqueKinds.indexOf(kind);\n    const targetIndex = 1 * uniqueClusterNames.length + uniqueKinds.length + uniqueReasons.indexOf(reasons[index]);\n    option.series.links.push({\n      source: sourceIndex,\n      target: targetIndex,\n      value: counts[index], // Use count values\n    });\n  });\n\n  // Create links from ClusterName to Kind\n  clusterNames.forEach((clusterName, index) => {\n    const sourceIndex = uniqueClusterNames.indexOf(clusterName);\n    const targetIndex = uniqueClusterNames.length + uniqueKinds.indexOf(kinds[index]);\n    option.series.links.push({\n      source: sourceIndex,\n      target: targetIndex,\n      value: 1,\n    });\n  });\n}\n\n\nreturn option;\n// Render the chart\nmyChart.setOption(option);\n\n",
        "google": {
          "callback": "gmapReady",
          "key": ""
        },
        "map": "none",
        "renderer": "canvas",
        "themeEditor": {
          "config": "{}",
          "height": 400,
          "name": "default"
        },
        "visualEditor": {
          "code": "return {\n  dataset: context.editor.dataset,\n  series: context.editor.series,\n  xAxis: {\n    type: 'time',\n  },\n  yAxis: {\n    type: 'value',\n    min: 'dataMin',\n  },\n}\n",
          "dataset": [],
          "series": []
        }
      },
      "pluginVersion": "6.0.0",
      "targets": [
        {
          "datasource": {
            "type": "vertamedia-clickhouse-datasource",
            "uid": "vertamedia-clickhouse-datasource"
          },
          "dateTimeType": "DATETIME",
          "extrapolate": true,
          "format": "table",
          "formattedQuery": "SELECT $timeSeries as t, count() FROM $table WHERE $timeFilter GROUP BY t ORDER BY t",
          "intervalFactor": 1,
          "query": "SELECT ClusterName, Kind, Reason, COUNT(*) as Count\nFROM default.events\nWHERE $timeFilterByColumn(EventTime) AND Kind IN ('PersistentVolume','PersistentVolumeClaim')\nGROUP BY ClusterName, Kind, Reason\nORDER BY Count DESC\n",
          "rawQuery": "SELECT ClusterName, Kind, Reason, COUNT(*) as Count\nFROM default.events\nWHERE EventTime >= toDateTime(1698931738) AND EventTime <= toDateTime(1698932038) AND Kind IN ('PersistentVolume','PersistentVolumeClaim')\nGROUP BY ClusterName, Kind, Reason\nORDER BY Count DESC",
          "refId": "A",
          "round": "0s",
          "skip_comments": true
        }
      ],
      "title": "PV, PVC events by cluster and reason",
      "type": "volkovlabs-echarts-panel"
    },
    {
      "datasource": {
        "type": "vertamedia-clickhouse-datasource",
        "uid": "vertamedia-clickhouse-datasource"
      },
      "gridPos": {
        "h": 13,
        "w": 24,
        "x": 0,
        "y": 41
      },
      "id": 7,
      "options": {
        "baidu": {
          "callback": "bmapReady",
          "key": ""
        },
        "editor": {
          "format": "auto",
          "height": 600
        },
        "editorMode": "code",
        "gaode": {
          "key": "",
          "plugin": "AMap.Scale,AMap.ToolBar"
        },
        "getOption": "let option; // Initialize the option variable\n\nif (typeof context.panel.data === 'undefined' || !context.panel.data.series || !context.panel.data.series[0] || !context.panel.data.series[0].fields) {\n  // Data is not available or doesn't have the expected structure\n  option = {\n    title: {\n      text: 'Data not available',\n      textStyle: {\n        fontSize: 24,\n        fontWeight: 'bold',\n      },\n      left: 'center',\n      top: 'middle',\n    },\n  };\n} else {\n  // Extract data from your JSON\n  const clusters = context.panel.data.series[0].fields[0].values;\n  const hosts = context.panel.data.series[0].fields[1].values;\n  const reasons = context.panel.data.series[0].fields[2].values;\n  const eventTimes = context.panel.data.series[0].fields[3].values;\n\n  // Create a hierarchical structure for the tree chart starting with ClusterName\n  const hierarchy = {\n    name: 'Root', // You can customize the name of the root node if needed\n    children: [],\n  };\n\n  for (let i = 0; i < clusters.length; i++) {\n    const cluster = clusters[i];\n    const host = hosts[i];\n    const reason = reasons[i];\n    const eventTime = eventTimes[i];\n\n    // Find or create the cluster node\n    let clusterNode = hierarchy.children.find((node) => node.name === cluster);\n    if (!clusterNode) {\n      clusterNode = { name: cluster, children: [] };\n      hierarchy.children.push(clusterNode);\n    }\n\n    // Find or create the host node under the cluster\n    let hostNode = clusterNode.children.find((node) => node.name === host);\n    if (!hostNode) {\n      hostNode = { name: host, children: [] };\n      clusterNode.children.push(hostNode);\n    }\n\n    // Find or create the reason node under the host\n    let reasonNode = hostNode.children.find((node) => node.name === reason);\n    if (!reasonNode) {\n      reasonNode = { name: reason, children: [] };\n      hostNode.children.push(reasonNode);\n    }\n\n    // Create the eventTime node under the reason\n    reasonNode.children.push({ name: eventTime });\n  }\n\n  // Create the tree chart using ECharts\n  option = {\n    tooltip: {\n      trigger: 'item',\n      triggerOn: 'mousemove',\n    },\n    series: [\n      {\n        type: 'tree',\n        data: hierarchy.children, // Use the children directly as root nodes\n        top: '1%',\n        left: '7%',\n        bottom: '1%',\n        right: '20%', // Adjust the right margin to provide more space for labels\n        symbolSize: 7,\n        label: {\n          position: 'inside', // Position labels inside the node\n          verticalAlign: 'middle',\n          align: 'center', // Center-align labels\n          fontSize: 15,\n          fontWeight: 'bold',\n        },\n        leaves: {\n          label: {\n            position: 'right', // Position labels inside the node\n            verticalAlign: 'middle',\n            align: 'left', // Center-align labels\n            fontSize: 15,\n            fontWeight: 'bold',\n          },\n        },\n        emphasis: {\n          focus: 'descendant',\n        },\n        expandAndCollapse: true,\n        animationDuration: 550,\n        animationDurationUpdate: 750,\n      },\n    ],\n  };\n}\n\nreturn option;\n",
        "google": {
          "callback": "gmapReady",
          "key": ""
        },
        "map": "none",
        "renderer": "canvas",
        "themeEditor": {
          "config": "{}",
          "height": 400,
          "name": "default"
        },
        "visualEditor": {
          "code": "return {\n  dataset: context.editor.dataset,\n  series: context.editor.series,\n  xAxis: {\n    type: 'time',\n  },\n  yAxis: {\n    type: 'value',\n    min: 'dataMin',\n  },\n}\n",
          "dataset": [],
          "series": []
        }
      },
      "pluginVersion": "6.0.0",
      "targets": [
        {
          "datasource": {
            "type": "vertamedia-clickhouse-datasource",
            "uid": "vertamedia-clickhouse-datasource"
          },
          "dateTimeType": "DATETIME",
          "extrapolate": true,
          "format": "table",
          "formattedQuery": "SELECT $timeSeries as t, count() FROM $table WHERE $timeFilter GROUP BY t ORDER BY t",
          "intervalFactor": 1,
          "query": "SELECT ClusterName, Host, Reason, EventTime\nFROM default.events\nWHERE $timeFilterByColumn(EventTime) AND ClusterName IN ($clusterName) AND Kind = 'Node' AND Kind != ' '\nGROUP BY ClusterName, Host, Reason, EventTime",
          "rawQuery": "SELECT ClusterName, Host, Reason, EventTime\nFROM default.events\nWHERE EventTime >= toDateTime(1698927382) AND EventTime <= toDateTime(1698927682) AND ClusterName IN ('beta-cluster') AND Kind = 'Node' AND Kind != ' '\nGROUP BY ClusterName, Host, Reason, EventTime",
          "refId": "A",
          "round": "0s",
          "skip_comments": true
        }
      ],
      "title": "Node Events by Cluster, Host, Reason, and EventTime",
      "type": "volkovlabs-echarts-panel"
    },
    {
      "datasource": {
        "type": "vertamedia-clickhouse-datasource",
        "uid": "vertamedia-clickhouse-datasource"
      },
      "gridPos": {
        "h": 11,
        "w": 24,
        "x": 0,
        "y": 54
      },
      "id": 5,
      "options": {
        "baidu": {
          "callback": "bmapReady",
          "key": ""
        },
        "editor": {
          "format": "auto",
          "height": 600
        },
        "editorMode": "code",
        "gaode": {
          "key": "",
          "plugin": "AMap.Scale,AMap.ToolBar"
        },
        "getOption": "let option; // Initialize the option variable\n\nif (typeof context.panel.data === 'undefined' || !context.panel.data.series || !context.panel.data.series[0] || !context.panel.data.series[0].fields) {\n  // Data is not available or doesn't have the expected structure\n  option = {\n    title: {\n      text: 'Data not available',\n      textStyle: {\n        fontSize: 24,\n        fontWeight: 'bold',\n      },\n      left: 'center',\n      top: 'middle',\n    },\n  };\n} else {\n  // Extract data from your JSON as before\n  const clusterNames = context.panel.data.series[0].fields[0].values; // New column for ClusterName\n  const namespaces = context.panel.data.series[0].fields[1].values;\n  const kinds = context.panel.data.series[0].fields[2].values; // Adjusted index for Kind\n  const counts = context.panel.data.series[0].fields[3].values; // New column for Count\n\n  // Create a hierarchical structure from the data without a root node\n  const hierarchy = {\n    name: 'root', // Use 'root' as a placeholder\n    children: [],\n  };\n\n  const seenClusterNames = new Set();\n  const seenNamespaces = new Set();\n\n  for (let i = 0; i < clusterNames.length; i++) {\n    const clusterName = clusterNames[i];\n    const namespace = namespaces[i];\n    const kind = kinds[i];\n    const count = counts[i]; // Get the count value\n\n    if (!seenClusterNames.has(clusterName)) {\n      seenClusterNames.add(clusterName);\n      const clusterNode = { name: clusterName, children: [] };\n      hierarchy.children.push(clusterNode);\n      seenNamespaces.clear(); // Reset seenNamespaces for each cluster\n    }\n\n    const clusterNode = hierarchy.children.find((node) => node.name === clusterName);\n\n    if (!seenNamespaces.has(namespace)) {\n      seenNamespaces.add(namespace);\n      const namespaceNode = { name: namespace, children: [] };\n      clusterNode.children.push(namespaceNode);\n    }\n\n    const namespaceNode = clusterNode.children.find((node) => node.name === namespace);\n    const kindNode = { name: kind, children: [{ name: `Count: ${count}` }] }; // Include the count as a child node\n    namespaceNode.children.push(kindNode);\n  }\n\n  // Create the tree chart using ECharts\n  option = {\n    tooltip: {\n      trigger: 'item',\n      triggerOn: 'mousemove',\n      formatter: function (params) {\n        const node = params.data;\n        let tooltip = '';\n        if (node.column) {\n          tooltip += `${node.column}: ${node.name}`;\n        } else {\n          tooltip += node.name;\n        }\n        return tooltip;\n      },\n    },\n    series: [\n      {\n        type: 'tree',\n        data: hierarchy.children, // Use the children directly\n        top: '1%',\n        left: '7%',\n        bottom: '1%',\n        right: '20%',\n        symbolSize: 7,\n        label: {\n          position: 'left',\n          verticalAlign: 'middle',\n          align: 'right',\n          fontSize: 15, // Increase the text size for regular nodes\n          fontWeight: 'bold', // Set the font weight to bold\n        },\n        leaves: {\n          label: {\n            position: 'right',\n            verticalAlign: 'middle',\n            align: 'left',\n            fontSize: 15, // Increase the text size for leaves\n            fontWeight: 'bold', // Set the font weight to bold\n          },\n        },\n        emphasis: {\n          focus: 'descendant',\n        },\n        expandAndCollapse: true,\n        animationDuration: 550,\n        animationDurationUpdate: 750,\n      },\n    ],\n  };\n}\n\nreturn option;\n",
        "google": {
          "callback": "gmapReady",
          "key": ""
        },
        "map": "none",
        "renderer": "canvas",
        "themeEditor": {
          "config": "{}",
          "height": 400,
          "name": "default"
        },
        "visualEditor": {
          "code": "return {\n  dataset: context.editor.dataset,\n  series: context.editor.series,\n  xAxis: {\n    type: 'time',\n  },\n  yAxis: {\n    type: 'value',\n    min: 'dataMin',\n  },\n}\n",
          "dataset": [],
          "series": []
        }
      },
      "pluginVersion": "6.0.0",
      "targets": [
        {
          "datasource": {
            "type": "vertamedia-clickhouse-datasource",
            "uid": "vertamedia-clickhouse-datasource"
          },
          "dateTimeType": "DATETIME",
          "extrapolate": true,
          "format": "table",
          "formattedQuery": "SELECT $timeSeries as t, count() FROM $table WHERE $timeFilter GROUP BY t ORDER BY t",
          "intervalFactor": 1,
          "query": "SELECT ClusterName, Namespace, Kind, count(*) AS count\nFROM default.events\nWHERE $timeFilterByColumn(EventTime) AND ClusterName IN ($clusterName) AND Namespace IN ($namespace)\nGROUP BY ClusterName, Namespace, Kind",
          "rawQuery": "SELECT ClusterName, Namespace, Kind, count(*) AS count\nFROM default.events\nWHERE EventTime >= toDateTime(1694603943) AND EventTime <= toDateTime(1694604243) AND ClusterName IN ('dev') AND Namespace IN ('kubviz','argocd','observability','default','tracetestdemo','sonarqube','kube-system','tek','quality','tekton-pipelines','sample','tekton-pipelines-resolvers','tekton-chains','cert-manager','qtapp','otel-collector','mysql','traefik')\nGROUP BY ClusterName, Namespace, Kind",
          "refId": "A",
          "round": "0s",
          "skip_comments": true
        }
      ],
      "title": "Kubernetes Workload",
      "type": "volkovlabs-echarts-panel"
    },
    {
      "datasource": {
        "type": "vertamedia-clickhouse-datasource",
        "uid": "vertamedia-clickhouse-datasource"
      },
      "description": "This stats panel shows the pod creation events.",
      "fieldConfig": {
        "defaults": {
          "color": {
            "fixedColor": "red",
            "mode": "fixed"
          },
          "mappings": [],
          "thresholds": {
            "mode": "absolute",
            "steps": [
              {
                "color": "green"
              },
              {
                "color": "red",
                "value": 80
              }
            ]
          }
        },
        "overrides": []
      },
      "gridPos": {
        "h": 7,
        "w": 24,
        "x": 0,
        "y": 65
      },
      "id": 4,
      "options": {
        "colorMode": "background",
        "graphMode": "area",
        "justifyMode": "auto",
        "orientation": "vertical",
        "reduceOptions": {
          "calcs": [
            "lastNotNull"
          ],
          "fields": "",
          "values": false
        },
        "textMode": "auto"
      },
      "pluginVersion": "10.0.3",
      "targets": [
        {
          "datasource": {
            "type": "vertamedia-clickhouse-datasource",
            "uid": "vertamedia-clickhouse-datasource"
          },
          "dateTimeType": "DATETIME",
          "extrapolate": true,
          "format": "table",
          "formattedQuery": "SELECT $timeSeries as t, count() FROM $table WHERE $timeFilter GROUP BY t ORDER BY t",
          "intervalFactor": 1,
          "query": "SELECT\n    count()\nFROM default.events\n\nWHERE $timeFilterByColumn(EventTime) AND Kind IN ('Pod') AND Reason IN ('Created') AND Namespace IN ($namespace)\n",
          "rawQuery": "SELECT\n    count()\nFROM default.events\n\nWHERE EventTime >= toDateTime(1693485465) AND EventTime <= toDateTime(1693486365) AND Kind IN ('Pod') AND Reason IN ('Created') AND Namespace IN ('argocd','kubviz','default','observability','otel-collector','tek','sonarqube','tekton-pipelines','cert-manager','kube-system','quality','traefik','tracetestdemo')",
          "refId": "A",
          "round": "0s",
          "skip_comments": true
        }
      ],
      "title": "number of pod creation events in Namespace: $namespace",
      "type": "stat"
    },
    {
      "datasource": {
        "type": "vertamedia-clickhouse-datasource",
        "uid": "vertamedia-clickhouse-datasource"
      },
      "description": "This table panal shows all the kubernetes datas.\nif its not showing the data check the time range and refresh.it will take some time to load the data. wait for sometime before clicking refresh another time.",
      "fieldConfig": {
        "defaults": {
          "color": {
            "mode": "thresholds"
          },
          "custom": {
            "align": "center",
            "cellOptions": {
              "type": "color-text"
            },
            "filterable": true,
            "inspect": false
          },
          "mappings": [],
          "thresholds": {
            "mode": "absolute",
            "steps": [
              {
                "color": "green"
              },
              {
                "color": "red",
                "value": 80
              }
            ]
          }
        },
        "overrides": []
      },
      "gridPos": {
        "h": 16,
        "w": 24,
        "x": 0,
        "y": 72
      },
      "id": 2,
      "options": {
        "cellHeight": "sm",
        "footer": {
          "countRows": false,
          "fields": "",
          "reducer": [
            "sum"
          ],
          "show": false
        },
        "showHeader": true
      },
      "pluginVersion": "10.0.3",
      "targets": [
        {
          "datasource": {
            "type": "vertamedia-clickhouse-datasource",
            "uid": "vertamedia-clickhouse-datasource"
          },
          "dateTimeType": "DATETIME",
          "extrapolate": true,
          "format": "table",
          "formattedQuery": "SELECT $timeSeries as t, count() FROM $table WHERE $timeFilter GROUP BY t ORDER BY t",
          "intervalFactor": 1,
          "query": "SELECT * FROM default.events\nWHERE $timeFilterByColumn(EventTime) AND Namespace IN ($namespace) AND Reason IN ($reason) AND Kind IN ($kind) AND ClusterName IN ($clusterName)\nORDER BY EventTime DESC",
          "rawQuery": "SELECT * FROM default.events\nWHERE EventTime >= toDateTime(1693486140) AND EventTime <= toDateTime(1693486440) AND Namespace IN ('argocd','kubviz','default','observability','otel-collector','tek','sonarqube','tekton-pipelines','cert-manager','kube-system','quality','traefik','tracetestdemo') AND Reason IN ('OperationCompleted','Pulled','Created','Started','OperationStarted','SuccessfulCreate','Scheduled','BackOff','Pulling','Unhealthy','Killing','FinalizerUpdate','WaitForFirstConsumer','Running','ExternalProvisioning','Provisioning','Pending','ProvisioningFailed','ProvisioningSucceeded','SuccessfulAttachVolume','Succeeded','Failed','FailedGetResourceMetric','FailedComputeMetricsReplicas','NodeNotReady','NodeHasSufficientMemory','NodeHasNoDiskPressure','NodeHasSufficientPID','NodeReady') AND Kind IN ('Application','Pod','ReplicaSet','StatefulSet','PipelineRun','PersistentVolumeClaim','TaskRun','HorizontalPodAutoscaler','Node') AND ClusterName IN ('dev')\nORDER BY EventTime DESC",
          "refId": "A",
          "round": "0s",
          "skip_comments": true
        }
      ],
      "title": "Kubernetes",
      "type": "table"
    }
  ],
  "refresh": "",
  "schemaVersion": 38,
  "style": "dark",
  "tags": [],
  "templating": {
    "list": [
      {
        "current": {
          "selected": false,
          "text": "All",
          "value": "$__all"
        },
        "datasource": {
          "type": "vertamedia-clickhouse-datasource",
          "uid": "vertamedia-clickhouse-datasource"
        },
        "definition": "SELECT Namespace FROM  default.events",
        "hide": 0,
        "includeAll": true,
        "multi": true,
        "name": "namespace",
        "options": [],
        "query": "SELECT Namespace FROM  default.events",
        "refresh": 2,
        "regex": "",
        "skipUrlSync": false,
        "sort": 0,
        "type": "query"
      },
      {
        "current": {
          "selected": false,
          "text": "All",
          "value": "$__all"
        },
        "datasource": {
          "type": "vertamedia-clickhouse-datasource",
          "uid": "vertamedia-clickhouse-datasource"
        },
        "definition": "SELECT Reason FROM default.events",
        "hide": 0,
        "includeAll": true,
        "multi": true,
        "name": "reason",
        "options": [],
        "query": "SELECT Reason FROM default.events",
        "refresh": 2,
        "regex": "",
        "skipUrlSync": false,
        "sort": 0,
        "type": "query"
      },
      {
        "current": {
          "selected": false,
          "text": "All",
          "value": "$__all"
        },
        "datasource": {
          "type": "vertamedia-clickhouse-datasource",
          "uid": "vertamedia-clickhouse-datasource"
        },
        "definition": "SELECT Kind FROM default.events",
        "hide": 0,
        "includeAll": true,
        "multi": true,
        "name": "kind",
        "options": [],
        "query": "SELECT Kind FROM default.events",
        "refresh": 2,
        "regex": "",
        "skipUrlSync": false,
        "sort": 0,
        "type": "query"
      },
      {
        "current": {
          "selected": false,
          "text": "All",
          "value": "$__all"
        },
        "datasource": {
          "type": "vertamedia-clickhouse-datasource",
          "uid": "vertamedia-clickhouse-datasource"
        },
        "definition": "SELECT ClusterName FROM default.events",
        "hide": 0,
        "includeAll": true,
        "multi": true,
        "name": "clusterName",
        "options": [],
        "query": "SELECT ClusterName FROM default.events",
        "refresh": 2,
        "regex": "",
        "skipUrlSync": false,
        "sort": 0,
        "type": "query"
      }
    ]
  },
  "time": {
    "from": "now-5m",
    "to": "now"
  },
  "timepicker": {},
  "timezone": "",
  "title": "Kubedata",
  "uid": "Qq-FK1rVz",
  "version": 3,
  "weekStart": ""
}
