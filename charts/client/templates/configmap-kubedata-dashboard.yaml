{{- if .Values.dashboards.enabled }}
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "client.fullname" . }}-kubedatas-dashboard
  annotations:
    grafana_folder: "Kubviz"
  labels:
    {{ .Values.dashboards.label }}: {{ .Values.dashboards.labelValue | quote }}
data:
  kubedatas.json: |-
    {
      "annotations": {
        "list": [
          {
            "builtIn": 1,
            "datasource": "-- Grafana --",
            "enable": true,
            "hide": true,
            "iconColor": "rgba(0, 211, 255, 1)",
            "name": "Annotations & Alerts",
            "target": {
              "limit": 100,
              "matchAny": false,
              "tags": [],
              "type": "dashboard"
            },
            "type": "dashboard"
          }
        ]
      },
      "editable": true,
      "fiscalYearStartMonth": 0,
      "graphTooltip": 0,
      "id": 31,
      "links": [],
      "liveNow": false,
      "panels": [
        {
          "datasource": {
            "type": "vertamedia-clickhouse-datasource",
            "uid": "{{ .Values.datasources.uid }}"
          },
          "gridPos": {
            "h": 14,
            "w": 24,
            "x": 0,
            "y": 0
          },
          "id": 6,
          "options": {
            "baidu": {
              "callback": "bmapReady",
              "key": ""
            },
            "editor": {
              "format": "auto",
              "height": 600
            },
            "gaode": {
              "key": "",
              "plugin": "AMap.Scale,AMap.ToolBar"
            },
            "getOption": "let option; // Initialize the option variable\n\nif (typeof data === 'undefined' || !data.series || !data.series[0] || !data.series[0].fields) {\n  // Data is not available or doesn't have the expected structure\n  option = {\n    title: {\n      text: 'Data not available',\n      textStyle: {\n        fontSize: 24,\n        fontWeight: 'bold',\n      },\n      left: 'center',\n      top: 'middle',\n    },\n  };\n} else {\n\n  // Define the data from your JSON\n  const clusterNames = data.series[0].fields[0].values;\n  const kinds = data.series[0].fields[1].values;\n  const reasons = data.series[0].fields[2].values;\n  const counts = data.series[0].fields[3].values;\n\n  // Create the Sankey chart configuration\n  option = {\n    series: {\n      type: 'sankey',\n      layout: 'none',\n      emphasis: {\n        focus: 'adjacency',\n      },\n      data: [],\n      links: [],\n    },\n    tooltip: {\n      trigger: 'item',\n      formatter: (params) => {\n        if (params.dataType === 'node') {\n          return params.name;\n        }\n        if (params.dataType === 'edge') {\n          return `Count: ${counts[params.dataIndex]}`; // Display count values\n        }\n        return '';\n      },\n    },\n  };\n\n  // Create nodes for ClusterName, Kind, and Reason\n  const uniqueClusterNames = Array.from(new Set(clusterNames));\n  const uniqueKinds = Array.from(new Set(kinds));\n  const uniqueReasons = Array.from(new Set(reasons));\n\n  uniqueClusterNames.forEach((name, index) => {\n    option.series.data.push({\n      name: name,\n    });\n  });\n\n  uniqueKinds.forEach((name, index) => {\n    option.series.data.push({\n      name: name,\n    });\n  });\n\n  uniqueReasons.forEach((name, index) => {\n    option.series.data.push({\n      name: name,\n    });\n  });\n\n\n  // Create links from Kind to Reason\n  kinds.forEach((kind, index) => {\n    const sourceIndex = uniqueClusterNames.length + uniqueKinds.indexOf(kind);\n    const targetIndex = 1 * uniqueClusterNames.length + uniqueKinds.length + uniqueReasons.indexOf(reasons[index]);\n    option.series.links.push({\n      source: sourceIndex,\n      target: targetIndex,\n      value: counts[index], // Use count values\n    });\n  });\n\n  // Create links from ClusterName to Kind\n  clusterNames.forEach((clusterName, index) => {\n    const sourceIndex = uniqueClusterNames.indexOf(clusterName);\n    const targetIndex = uniqueClusterNames.length + uniqueKinds.indexOf(kinds[index]);\n    option.series.links.push({\n      source: sourceIndex,\n      target: targetIndex,\n      value: 1,\n    });\n  });\n}\n\n\nreturn option;\n// Render the chart\nmyChart.setOption(option);",
            "google": {
              "callback": "gmapReady",
              "key": ""
            },
            "map": "none",
            "renderer": "canvas",
            "themeEditor": {
              "config": "{}",
              "height": 400,
              "name": "default"
            }
          },
          "targets": [
            {
              "datasource": {
                "type": "vertamedia-clickhouse-datasource",
                "uid": "{{ .Values.datasources.uid }}"
              },
              "dateTimeType": "DATETIME",
              "extrapolate": true,
              "format": "table",
              "formattedQuery": "SELECT $timeSeries as t, count() FROM $table WHERE $timeFilter GROUP BY t ORDER BY t",
              "intervalFactor": 1,
              "query": "SELECT ClusterName, Kind, Reason, COUNT(*) as Count\nFROM default.events\nWHERE $timeFilterByColumn(EventTime) AND ClusterName IN ($clusterName) AND Kind IN ('Pod', 'Node', 'Deployment')\nGROUP BY ClusterName, Kind, Reason\nORDER BY Count DESC",
              "rawQuery": "SELECT ClusterName, Kind, Reason, COUNT(*) as Count\nFROM default.events\nWHERE EventTime >= toDateTime(1698927439) AND EventTime <= toDateTime(1698927739) AND ClusterName IN ('beta-cluster') AND Kind IN ('Pod', 'Node', 'Deployment')\nGROUP BY ClusterName, Kind, Reason\nORDER BY Count DESC",
              "refId": "A",
              "round": "0s",
              "skip_comments": true
            }
          ],
          "title": "K8s metrics status",
          "type": "volkovlabs-echarts-panel"
        },
        {
          "datasource": {
            "type": "vertamedia-clickhouse-datasource",
            "uid": "{{ .Values.datasources.uid }}"
          },
          "gridPos": {
            "h": 8,
            "w": 12,
            "x": 0,
            "y": 14
          },
          "id": 8,
          "options": {
            "baidu": {
              "callback": "bmapReady",
              "key": ""
            },
            "editor": {
              "format": "auto",
              "height": 600
            },
            "gaode": {
              "key": "",
              "plugin": "AMap.Scale,AMap.ToolBar"
            },
            "getOption": "let option; // Initialize the option variable\n\nif (typeof data === 'undefined' || !data.series || !data.series[0] || !data.series[0].fields) {\n  // Data is not available or doesn't have the expected structure\n  option = {\n    title: {\n      text: 'Data not available',\n      textStyle: {\n        fontSize: 24,\n        fontWeight: 'bold',\n      },\n      left: 'center',\n      top: 'middle',\n    },\n  };\n} else {\n\n  // Define the data from your JSON\n  const clusterNames = data.series[0].fields[0].values;\n  const kinds = data.series[0].fields[1].values;\n  const reasons = data.series[0].fields[2].values;\n  const counts = data.series[0].fields[3].values;\n\n  // Create the Sankey chart configuration\n  option = {\n    series: {\n      type: 'sankey',\n      layout: 'none',\n      emphasis: {\n        focus: 'adjacency',\n      },\n      data: [],\n      links: [],\n    },\n    tooltip: {\n      trigger: 'item',\n      formatter: (params) => {\n        if (params.dataType === 'node') {\n          return params.name;\n        }\n        if (params.dataType === 'edge') {\n          return `Count: ${counts[params.dataIndex]}`; // Display count values\n        }\n        return '';\n      },\n    },\n  };\n\n  // Create nodes for ClusterName, Kind, and Reason\n  const uniqueClusterNames = Array.from(new Set(clusterNames));\n  const uniqueKinds = Array.from(new Set(kinds));\n  const uniqueReasons = Array.from(new Set(reasons));\n\n  uniqueClusterNames.forEach((name, index) => {\n    option.series.data.push({\n      name: name,\n    });\n  });\n\n  uniqueKinds.forEach((name, index) => {\n    option.series.data.push({\n      name: name,\n    });\n  });\n\n  uniqueReasons.forEach((name, index) => {\n    option.series.data.push({\n      name: name,\n    });\n  });\n\n\n  // Create links from Kind to Reason\n  kinds.forEach((kind, index) => {\n    const sourceIndex = uniqueClusterNames.length + uniqueKinds.indexOf(kind);\n    const targetIndex = 1 * uniqueClusterNames.length + uniqueKinds.length + uniqueReasons.indexOf(reasons[index]);\n    option.series.links.push({\n      source: sourceIndex,\n      target: targetIndex,\n      value: counts[index], // Use count values\n    });\n  });\n\n  // Create links from ClusterName to Kind\n  clusterNames.forEach((clusterName, index) => {\n    const sourceIndex = uniqueClusterNames.indexOf(clusterName);\n    const targetIndex = uniqueClusterNames.length + uniqueKinds.indexOf(kinds[index]);\n    option.series.links.push({\n      source: sourceIndex,\n      target: targetIndex,\n      value: 1,\n    });\n  });\n}\n\n\n\nreturn option;\n// Render the chart\nmyChart.setOption(option);",
            "google": {
              "callback": "gmapReady",
              "key": ""
            },
            "map": "none",
            "renderer": "canvas",
            "themeEditor": {
              "config": "{}",
              "height": 400,
              "name": "default"
            }
          },
          "targets": [
            {
              "datasource": {
                "type": "vertamedia-clickhouse-datasource",
                "uid": "{{ .Values.datasources.uid }}"
              },
              "dateTimeType": "DATETIME",
              "extrapolate": true,
              "format": "table",
              "formattedQuery": "SELECT $timeSeries as t, count() FROM $table WHERE $timeFilter GROUP BY t ORDER BY t",
              "intervalFactor": 1,
              "query": "SELECT ClusterName, Kind, Reason, COUNT(*) as Count\nFROM default.events\nWHERE $timeFilterByColumn(EventTime) AND ClusterName IN ($clusterName) AND Kind IN ('Service')\nGROUP BY ClusterName, Kind, Reason\nORDER BY Count DESC",
              "rawQuery": "SELECT ClusterName, Kind, Reason, COUNT(*) as Count\nFROM default.events\nWHERE EventTime >= toDateTime(1698931712) AND EventTime <= toDateTime(1698932012) AND ClusterName IN ('beta-cluster') AND Kind IN ('Service')\nGROUP BY ClusterName, Kind, Reason\nORDER BY Count DESC",
              "refId": "A",
              "round": "0s",
              "skip_comments": true
            }
          ],
          "title": "Service Events by Cluster and Reason",
          "type": "volkovlabs-echarts-panel"
        },
        {
          "datasource": {
            "type": "vertamedia-clickhouse-datasource",
            "uid": "{{ .Values.datasources.uid }}"
          },
          "gridPos": {
            "h": 8,
            "w": 12,
            "x": 12,
            "y": 14
          },
          "id": 9,
          "options": {
            "baidu": {
              "callback": "bmapReady",
              "key": ""
            },
            "editor": {
              "format": "auto",
              "height": 600
            },
            "gaode": {
              "key": "",
              "plugin": "AMap.Scale,AMap.ToolBar"
            },
            "getOption": "let option; // Initialize the option variable\n\nif (typeof data === 'undefined' || !data.series || !data.series[0] || !data.series[0].fields) {\n  // Data is not available or doesn't have the expected structure\n  option = {\n    title: {\n      text: 'Data not available',\n      textStyle: {\n        fontSize: 24,\n        fontWeight: 'bold',\n      },\n      left: 'center',\n      top: 'middle',\n    },\n  };\n} else {\n\n  // Define the data from your JSON\n  const clusterNames = data.series[0].fields[0].values;\n  const kinds = data.series[0].fields[1].values;\n  const reasons = data.series[0].fields[2].values;\n  const counts = data.series[0].fields[3].values;\n\n  // Create the Sankey chart configuration\n  option = {\n    series: {\n      type: 'sankey',\n      layout: 'none',\n      emphasis: {\n        focus: 'adjacency',\n      },\n      data: [],\n      links: [],\n    },\n    tooltip: {\n      trigger: 'item',\n      formatter: (params) => {\n        if (params.dataType === 'node') {\n          return params.name;\n        }\n        if (params.dataType === 'edge') {\n          return `Count: ${counts[params.dataIndex]}`; // Display count values\n        }\n        return '';\n      },\n    },\n  };\n\n  // Create nodes for ClusterName, Kind, and Reason\n  const uniqueClusterNames = Array.from(new Set(clusterNames));\n  const uniqueKinds = Array.from(new Set(kinds));\n  const uniqueReasons = Array.from(new Set(reasons));\n\n  uniqueClusterNames.forEach((name, index) => {\n    option.series.data.push({\n      name: name,\n    });\n  });\n\n  uniqueKinds.forEach((name, index) => {\n    option.series.data.push({\n      name: name,\n    });\n  });\n\n  uniqueReasons.forEach((name, index) => {\n    option.series.data.push({\n      name: name,\n    });\n  });\n\n\n  // Create links from Kind to Reason\n  kinds.forEach((kind, index) => {\n    const sourceIndex = uniqueClusterNames.length + uniqueKinds.indexOf(kind);\n    const targetIndex = 1 * uniqueClusterNames.length + uniqueKinds.length + uniqueReasons.indexOf(reasons[index]);\n    option.series.links.push({\n      source: sourceIndex,\n      target: targetIndex,\n      value: counts[index], // Use count values\n    });\n  });\n\n  // Create links from ClusterName to Kind\n  clusterNames.forEach((clusterName, index) => {\n    const sourceIndex = uniqueClusterNames.indexOf(clusterName);\n    const targetIndex = uniqueClusterNames.length + uniqueKinds.indexOf(kinds[index]);\n    option.series.links.push({\n      source: sourceIndex,\n      target: targetIndex,\n      value: 1,\n    });\n  });\n}\n\n\nreturn option;\n// Render the chart\nmyChart.setOption(option);\n\n",
            "google": {
              "callback": "gmapReady",
              "key": ""
            },
            "map": "none",
            "renderer": "canvas",
            "themeEditor": {
              "config": "{}",
              "height": 400,
              "name": "default"
            }
          },
          "targets": [
            {
              "datasource": {
                "type": "vertamedia-clickhouse-datasource",
                "uid": "{{ .Values.datasources.uid }}"
              },
              "dateTimeType": "DATETIME",
              "extrapolate": true,
              "format": "table",
              "formattedQuery": "SELECT $timeSeries as t, count() FROM $table WHERE $timeFilter GROUP BY t ORDER BY t",
              "intervalFactor": 1,
              "query": "SELECT ClusterName, Kind, Reason, COUNT(*) as Count\nFROM default.events\nWHERE $timeFilterByColumn(EventTime) AND Kind IN ('PersistentVolume','PersistentVolumeClaim')\nGROUP BY ClusterName, Kind, Reason\nORDER BY Count DESC\n",
              "rawQuery": "SELECT ClusterName, Kind, Reason, COUNT(*) as Count\nFROM default.events\nWHERE EventTime >= toDateTime(1698931738) AND EventTime <= toDateTime(1698932038) AND Kind IN ('PersistentVolume','PersistentVolumeClaim')\nGROUP BY ClusterName, Kind, Reason\nORDER BY Count DESC",
              "refId": "A",
              "round": "0s",
              "skip_comments": true
            }
          ],
          "title": "PV, PVC events by cluster and reason",
          "type": "volkovlabs-echarts-panel"
        },
        {
          "datasource": {
            "type": "vertamedia-clickhouse-datasource",
            "uid": "{{ .Values.datasources.uid }}"
          },
          "gridPos": {
            "h": 13,
            "w": 24,
            "x": 0,
            "y": 22
          },
          "id": 7,
          "options": {
            "baidu": {
              "callback": "bmapReady",
              "key": ""
            },
            "editor": {
              "format": "auto",
              "height": 600
            },
            "gaode": {
              "key": "",
              "plugin": "AMap.Scale,AMap.ToolBar"
            },
            "getOption": "let option; // Initialize the option variable\n\nif (typeof data === 'undefined' || !data.series || !data.series[0] || !data.series[0].fields) {\n  // Data is not available or doesn't have the expected structure\n  option = {\n    title: {\n      text: 'Data not available',\n      textStyle: {\n        fontSize: 24,\n        fontWeight: 'bold',\n      },\n      left: 'center',\n      top: 'middle',\n    },\n  };\n} else {\n\n  // Extract data from your JSON\n  const clusters = data.series[0].fields[0].values;\n  const hosts = data.series[0].fields[1].values;\n  const reasons = data.series[0].fields[2].values;\n  const eventTimes = data.series[0].fields[3].values;\n\n  // Create a hierarchical structure for the tree chart starting with ClusterName\n  const hierarchy = {\n    name: 'Cluster Hierarchy',\n    children: [],\n  };\n\n  for (let i = 0; i < clusters.length; i++) {\n    const cluster = clusters[i];\n    const host = hosts[i];\n    const reason = reasons[i];\n    const eventTime = eventTimes[i];\n\n    // Find or create the cluster node\n    let clusterNode = hierarchy.children.find((node) => node.name === cluster);\n    if (!clusterNode) {\n      clusterNode = { name: cluster, children: [] };\n      hierarchy.children.push(clusterNode);\n    }\n\n    // Find or create the host node under the cluster\n    let hostNode = clusterNode.children.find((node) => node.name === host);\n    if (!hostNode) {\n      hostNode = { name: host, children: [] };\n      clusterNode.children.push(hostNode);\n    }\n\n    // Find or create the reason node under the host\n    let reasonNode = hostNode.children.find((node) => node.name === reason);\n    if (!reasonNode) {\n      reasonNode = { name: reason, children: [] };\n      hostNode.children.push(reasonNode);\n    }\n\n    // Create the eventTime node under the reason\n    reasonNode.children.push({ name: eventTime });\n  }\n\n  // Create the tree chart using ECharts\n  const option = {\n    tooltip: {\n      trigger: 'item',\n      triggerOn: 'mousemove',\n    },\n    series: [\n      {\n        type: 'tree',\n        data: hierarchy.children, // Start directly from the Cluster Hierarchy node\n        top: '1%',\n        left: '7%',\n        bottom: '1%',\n        right: '20%', // Adjust the right margin to provide more space for labels\n        symbolSize: 7,\n        label: {\n          position: 'inside', // Position labels inside the node\n          verticalAlign: 'middle',\n          align: 'center', // Center-align labels\n          fontSize: 15,\n          fontWeight: 'bold',\n        },\n        leaves: {\n          label: {\n            position: 'right', // Position labels inside the node\n            verticalAlign: 'middle',\n            align: 'left', // Center-align labels\n            fontSize: 15,\n            fontWeight: 'bold',\n          },\n        },\n        emphasis: {\n          focus: 'descendant',\n        },\n        expandAndCollapse: true,\n        animationDuration: 550,\n        animationDurationUpdate: 750,\n      },\n    ],\n  };\n}\nreturn option;",
            "google": {
              "callback": "gmapReady",
              "key": ""
            },
            "map": "none",
            "renderer": "canvas",
            "themeEditor": {
              "config": "{}",
              "height": 400,
              "name": "default"
            }
          },
          "targets": [
            {
              "datasource": {
                "type": "vertamedia-clickhouse-datasource",
                "uid": "{{ .Values.datasources.uid }}"
              },
              "dateTimeType": "DATETIME",
              "extrapolate": true,
              "format": "table",
              "formattedQuery": "SELECT $timeSeries as t, count() FROM $table WHERE $timeFilter GROUP BY t ORDER BY t",
              "intervalFactor": 1,
              "query": "SELECT ClusterName, Host, Reason, EventTime\nFROM default.events\nWHERE $timeFilterByColumn(EventTime) AND ClusterName IN ($clusterName) AND Kind = 'Node' AND Kind != ' '\nGROUP BY ClusterName, Host, Reason, EventTime",
              "rawQuery": "SELECT ClusterName, Host, Reason, EventTime\nFROM default.events\nWHERE EventTime >= toDateTime(1698927382) AND EventTime <= toDateTime(1698927682) AND ClusterName IN ('beta-cluster') AND Kind = 'Node' AND Kind != ' '\nGROUP BY ClusterName, Host, Reason, EventTime",
              "refId": "A",
              "round": "0s",
              "skip_comments": true
            }
          ],
          "title": "Node Events by Cluster, Host, Reason, and EventTime",
          "type": "volkovlabs-echarts-panel"
        },
        {
          "datasource": {
            "type": "vertamedia-clickhouse-datasource",
            "uid": "{{ .Values.datasources.uid }}"
          },
          "gridPos": {
            "h": 11,
            "w": 24,
            "x": 0,
            "y": 35
          },
          "id": 5,
          "options": {
            "baidu": {
              "callback": "bmapReady",
              "key": ""
            },
            "editor": {
              "format": "auto",
              "height": 600
            },
            "gaode": {
              "key": "",
              "plugin": "AMap.Scale,AMap.ToolBar"
            },
            "getOption": "let option; // Initialize the option variable\n\nif (typeof data === 'undefined' || !data.series || !data.series[0] || !data.series[0].fields) {\n  // Data is not available or doesn't have the expected structure\n  option = {\n    title: {\n      text: 'Data not available',\n      textStyle: {\n        fontSize: 24,\n        fontWeight: 'bold',\n      },\n      left: 'center',\n      top: 'middle',\n    },\n  };\n} else {\n  // Extract data from your JSON as before\n  const clusterNames = data.series[0].fields[0].values; // New column for ClusterName\n  const namespaces = data.series[0].fields[1].values;\n  const kinds = data.series[0].fields[2].values; // Adjusted index for Kind\n  const counts = data.series[0].fields[3].values; // New column for Count\n\n  // Create a hierarchical structure from the data without a root node\n  const hierarchy = {\n    name: 'root', // Use 'root' as a placeholder\n    children: [],\n  };\n\n  const seenClusterNames = new Set();\n  const seenNamespaces = new Set();\n\n  for (let i = 0; i < clusterNames.length; i++) {\n    const clusterName = clusterNames[i];\n    const namespace = namespaces[i];\n    const kind = kinds[i];\n    const count = counts[i]; // Get the count value\n\n    if (!seenClusterNames.has(clusterName)) {\n      seenClusterNames.add(clusterName);\n      const clusterNode = { name: clusterName, children: [] };\n      hierarchy.children.push(clusterNode);\n      seenNamespaces.clear(); // Reset seenNamespaces for each cluster\n    }\n\n    const clusterNode = hierarchy.children.find((node) => node.name === clusterName);\n\n    if (!seenNamespaces.has(namespace)) {\n      seenNamespaces.add(namespace);\n      const namespaceNode = { name: namespace, children: [] };\n      clusterNode.children.push(namespaceNode);\n    }\n\n    const namespaceNode = clusterNode.children.find((node) => node.name === namespace);\n    const kindNode = { name: kind, children: [{ name: `Count: ${count}` }] }; // Include the count as a child node\n    namespaceNode.children.push(kindNode);\n  }\n\n  // Create the tree chart using ECharts\n  option = {\n    tooltip: {\n      trigger: 'item',\n      triggerOn: 'mousemove',\n      formatter: function (params) {\n        const node = params.data;\n        let tooltip = '';\n        if (node.column) {\n          tooltip += `${node.column}: ${node.name}`;\n        } else {\n          tooltip += node.name;\n        }\n        return tooltip;\n      },\n    },\n    series: [\n      {\n        type: 'tree',\n        data: hierarchy.children, // Use the children directly\n        top: '1%',\n        left: '7%',\n        bottom: '1%',\n        right: '20%',\n        symbolSize: 7,\n        label: {\n          position: 'left',\n          verticalAlign: 'middle',\n          align: 'right',\n          fontSize: 15, // Increase the text size for regular nodes\n          fontWeight: 'bold', // Set the font weight to bold\n        },\n        leaves: {\n          label: {\n            position: 'right',\n            verticalAlign: 'middle',\n            align: 'left',\n            fontSize: 15, // Increase the text size for leaves\n            fontWeight: 'bold', // Set the font weight to bold\n          },\n        },\n        emphasis: {\n          focus: 'descendant',\n        },\n        expandAndCollapse: true,\n        animationDuration: 550,\n        animationDurationUpdate: 750,\n      },\n    ],\n  };\n}\n\nreturn option;\n",
            "google": {
              "callback": "gmapReady",
              "key": ""
            },
            "map": "none",
            "renderer": "canvas",
            "themeEditor": {
              "config": "{}",
              "height": 400,
              "name": "default"
            }
          },
          "targets": [
            {
              "datasource": {
                "type": "vertamedia-clickhouse-datasource",
                "uid": "{{ .Values.datasources.uid }}"
              },
              "dateTimeType": "DATETIME",
              "extrapolate": true,
              "format": "table",
              "formattedQuery": "SELECT $timeSeries as t, count() FROM $table WHERE $timeFilter GROUP BY t ORDER BY t",
              "intervalFactor": 1,
              "query": "SELECT ClusterName, Namespace, Kind, count(*) AS count\nFROM default.events\nWHERE $timeFilterByColumn(EventTime) AND ClusterName IN ($clusterName) AND Namespace IN ($namespace)\nGROUP BY ClusterName, Namespace, Kind",
              "rawQuery": "SELECT ClusterName, Namespace, Kind, count(*) AS count\nFROM default.events\nWHERE EventTime >= toDateTime(1694603943) AND EventTime <= toDateTime(1694604243) AND ClusterName IN ('dev') AND Namespace IN ('kubviz','argocd','observability','default','tracetestdemo','sonarqube','kube-system','tek','quality','tekton-pipelines','sample','tekton-pipelines-resolvers','tekton-chains','cert-manager','qtapp','otel-collector','mysql','traefik')\nGROUP BY ClusterName, Namespace, Kind",
              "refId": "A",
              "round": "0s",
              "skip_comments": true
            }
          ],
          "title": "Kubernetes Workload",
          "type": "volkovlabs-echarts-panel"
        },
        {
          "datasource": {
            "type": "vertamedia-clickhouse-datasource",
            "uid": "{{ .Values.datasources.uid }}"
          },
          "description": "This stats panel shows the pod creation events.",
          "fieldConfig": {
            "defaults": {
              "color": {
                "fixedColor": "red",
                "mode": "fixed"
              },
              "mappings": [],
              "thresholds": {
                "mode": "absolute",
                "steps": [
                  {
                    "color": "green"
                  },
                  {
                    "color": "red",
                    "value": 80
                  }
                ]
              }
            },
            "overrides": []
          },
          "gridPos": {
            "h": 7,
            "w": 24,
            "x": 0,
            "y": 46
          },
          "id": 4,
          "options": {
            "colorMode": "background",
            "graphMode": "area",
            "justifyMode": "auto",
            "orientation": "vertical",
            "reduceOptions": {
              "calcs": [
                "lastNotNull"
              ],
              "fields": "",
              "values": false
            },
            "textMode": "auto"
          },
          "pluginVersion": "10.0.3",
          "targets": [
            {
              "datasource": {
                "type": "vertamedia-clickhouse-datasource",
                "uid": "{{ .Values.datasources.uid }}"
              },
              "dateTimeType": "DATETIME",
              "extrapolate": true,
              "format": "table",
              "formattedQuery": "SELECT $timeSeries as t, count() FROM $table WHERE $timeFilter GROUP BY t ORDER BY t",
              "intervalFactor": 1,
              "query": "SELECT\n    count()\nFROM default.events\n\nWHERE $timeFilterByColumn(EventTime) AND Kind IN ('Pod') AND Reason IN ('Created') AND Namespace IN ($namespace)\n",
              "rawQuery": "SELECT\n    count()\nFROM default.events\n\nWHERE EventTime >= toDateTime(1693485465) AND EventTime <= toDateTime(1693486365) AND Kind IN ('Pod') AND Reason IN ('Created') AND Namespace IN ('argocd','kubviz','default','observability','otel-collector','tek','sonarqube','tekton-pipelines','cert-manager','kube-system','quality','traefik','tracetestdemo')",
              "refId": "A",
              "round": "0s",
              "skip_comments": true
            }
          ],
          "title": "number of pod creation events in Namespace: $namespace",
          "type": "stat"
        },
        {
          "datasource": {
            "type": "vertamedia-clickhouse-datasource",
            "uid": "{{ .Values.datasources.uid }}"
          },
          "description": "This table panal shows all the kubernetes datas.\nif its not showing the data check the time range and refresh.it will take some time to load the data. wait for sometime before clicking refresh another time.",
          "fieldConfig": {
            "defaults": {
              "color": {
                "mode": "thresholds"
              },
              "custom": {
                "align": "center",
                "cellOptions": {
                  "type": "color-text"
                },
                "filterable": true,
                "inspect": false
              },
              "mappings": [],
              "thresholds": {
                "mode": "absolute",
                "steps": [
                  {
                    "color": "green"
                  },
                  {
                    "color": "red",
                    "value": 80
                  }
                ]
              }
            },
            "overrides": []
          },
          "gridPos": {
            "h": 16,
            "w": 24,
            "x": 0,
            "y": 53
          },
          "id": 2,
          "options": {
            "cellHeight": "sm",
            "footer": {
              "countRows": false,
              "fields": "",
              "reducer": [
                "sum"
              ],
              "show": false
            },
            "showHeader": true
          },
          "pluginVersion": "10.0.3",
          "targets": [
            {
              "datasource": {
                "type": "vertamedia-clickhouse-datasource",
                "uid": "{{ .Values.datasources.uid }}"
              },
              "dateTimeType": "DATETIME",
              "extrapolate": true,
              "format": "table",
              "formattedQuery": "SELECT $timeSeries as t, count() FROM $table WHERE $timeFilter GROUP BY t ORDER BY t",
              "intervalFactor": 1,
              "query": "SELECT * FROM default.events\nWHERE $timeFilterByColumn(EventTime) AND Namespace IN ($namespace) AND Reason IN ($reason) AND Kind IN ($kind) AND ClusterName IN ($clusterName)\nORDER BY EventTime DESC",
              "rawQuery": "SELECT * FROM default.events\nWHERE EventTime >= toDateTime(1693486140) AND EventTime <= toDateTime(1693486440) AND Namespace IN ('argocd','kubviz','default','observability','otel-collector','tek','sonarqube','tekton-pipelines','cert-manager','kube-system','quality','traefik','tracetestdemo') AND Reason IN ('OperationCompleted','Pulled','Created','Started','OperationStarted','SuccessfulCreate','Scheduled','BackOff','Pulling','Unhealthy','Killing','FinalizerUpdate','WaitForFirstConsumer','Running','ExternalProvisioning','Provisioning','Pending','ProvisioningFailed','ProvisioningSucceeded','SuccessfulAttachVolume','Succeeded','Failed','FailedGetResourceMetric','FailedComputeMetricsReplicas','NodeNotReady','NodeHasSufficientMemory','NodeHasNoDiskPressure','NodeHasSufficientPID','NodeReady') AND Kind IN ('Application','Pod','ReplicaSet','StatefulSet','PipelineRun','PersistentVolumeClaim','TaskRun','HorizontalPodAutoscaler','Node') AND ClusterName IN ('dev')\nORDER BY EventTime DESC",
              "refId": "A",
              "round": "0s",
              "skip_comments": true
            }
          ],
          "title": "Kubernetes",
          "type": "table"
        }
      ],
      "refresh": "",
      "schemaVersion": 38,
      "style": "dark",
      "tags": [],
      "templating": {
        "list": [
          {
            "current": {
              "selected": false,
              "text": "All",
              "value": "$__all"
            },
            "datasource": {
              "type": "vertamedia-clickhouse-datasource",
              "uid": "{{ .Values.datasources.uid }}"
            },
            "definition": "SELECT Namespace FROM  default.events",
            "hide": 0,
            "includeAll": true,
            "multi": true,
            "name": "namespace",
            "options": [],
            "query": "SELECT Namespace FROM  default.events",
            "refresh": 2,
            "regex": "",
            "skipUrlSync": false,
            "sort": 0,
            "type": "query"
          },
          {
            "current": {
              "selected": false,
              "text": "All",
              "value": "$__all"
            },
            "datasource": {
              "type": "vertamedia-clickhouse-datasource",
              "uid": "{{ .Values.datasources.uid }}"
            },
            "definition": "SELECT Reason FROM default.events",
            "hide": 0,
            "includeAll": true,
            "multi": true,
            "name": "reason",
            "options": [],
            "query": "SELECT Reason FROM default.events",
            "refresh": 2,
            "regex": "",
            "skipUrlSync": false,
            "sort": 0,
            "type": "query"
          },
          {
            "current": {
              "selected": false,
              "text": "All",
              "value": "$__all"
            },
            "datasource": {
              "type": "vertamedia-clickhouse-datasource",
              "uid": "{{ .Values.datasources.uid }}"
            },
            "definition": "SELECT Kind FROM default.events",
            "hide": 0,
            "includeAll": true,
            "multi": true,
            "name": "kind",
            "options": [],
            "query": "SELECT Kind FROM default.events",
            "refresh": 2,
            "regex": "",
            "skipUrlSync": false,
            "sort": 0,
            "type": "query"
          },
          {
            "current": {
              "selected": false,
              "text": "All",
              "value": "$__all"
            },
            "datasource": {
              "type": "vertamedia-clickhouse-datasource",
              "uid": "{{ .Values.datasources.uid }}"
            },
            "definition": "SELECT ClusterName FROM default.events",
            "hide": 0,
            "includeAll": true,
            "multi": true,
            "name": "clusterName",
            "options": [],
            "query": "SELECT ClusterName FROM default.events",
            "refresh": 2,
            "regex": "",
            "skipUrlSync": false,
            "sort": 0,
            "type": "query"
          }
        ]
      },
      "time": {
        "from": "now-5m",
        "to": "now"
      },
      "timepicker": {},
      "timezone": "",
      "title": "Kubedata",
      "uid": "Qq-FK1rVz",
      "version": 1,
      "weekStart": ""
    }
{{- end }}