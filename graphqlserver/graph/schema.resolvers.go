package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.42

import (
	"context"
	"fmt"

	"github.com/intelops/kubviz/graphqlserver/graph/model"
)

func (r *queryResolver) AllNamespaceData(ctx context.Context) ([]*model.NamespaceData, error) {

	var namespaceDataList []*model.NamespaceData

	resolver := NewResolver()

	namespaces, err := r.fetchNamespacesFromDatabase(ctx)
	if err != nil {
		return nil, fmt.Errorf("error fetching namespaces: %v", err)
	}

	for _, ns := range namespaces {
		outdatedImages, err := resolver.fetchOutdatedImages(ctx, ns)
		if err != nil {
			return nil, fmt.Errorf("error fetching outdated images for namespace %s: %v", ns, err)
		}

		kubeScores, err := resolver.fetchKubeScores(ctx, ns)
		if err != nil {
			return nil, fmt.Errorf("error fetching kube scores for namespace %s: %v", ns, err)
		}

		resources, err := resolver.fetchResources(ctx, ns)
		if err != nil {
			return nil, fmt.Errorf("error fetching resources for namespace %s: %v", ns, err)
		}

		nd := &model.NamespaceData{
			Namespace:      ns,
			OutdatedImages: outdatedImages,
			KubeScores:     kubeScores,
			Resources:      resources,
		}

		namespaceDataList = append(namespaceDataList, nd)
	}

	return namespaceDataList, nil
}
func (r *Resolver) fetchNamespacesFromDatabase(ctx context.Context) ([]string, error) {

	query := `SELECT DISTINCT Namespace FROM events`

	rows, err := r.DB.QueryContext(ctx, query)
	if err != nil {
		return nil, fmt.Errorf("error executing query: %v", err)
	}
	defer rows.Close()

	var namespaces []string
	for rows.Next() {
		var namespace string
		if err := rows.Scan(&namespace); err != nil {
			return nil, fmt.Errorf("error scanning row: %v", err)
		}
		namespaces = append(namespaces, namespace)
	}

	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("error iterating rows: %v", err)
	}

	return namespaces, nil
}
func (r *Resolver) fetchOutdatedImages(ctx context.Context, namespace string) ([]*model.OutdatedImage, error) {

	query := `SELECT ClusterName, Namespace, Pod, CurrentImage, CurrentTag, LatestVersion, VersionsBehind, EventTime FROM outdated_images WHERE Namespace = ?`

	rows, err := r.DB.QueryContext(ctx, query, namespace)
	if err != nil {
		return nil, fmt.Errorf("error executing query: %v", err)
	}
	defer rows.Close()

	var outdatedImages []*model.OutdatedImage
	for rows.Next() {
		var oi model.OutdatedImage
		if err := rows.Scan(&oi.ClusterName, &oi.Namespace, &oi.Pod, &oi.CurrentImage, &oi.CurrentTag, &oi.LatestVersion, &oi.VersionsBehind, &oi.EventTime); err != nil {
			return nil, fmt.Errorf("error scanning row: %v", err)
		}
		outdatedImages = append(outdatedImages, &oi)
	}

	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("error iterating rows: %v", err)
	}

	return outdatedImages, nil
}

func (r *Resolver) fetchKubeScores(ctx context.Context, namespace string) ([]*model.KubeScore, error) {

	query := `SELECT id, ClusterName, ObjectName, Kind, ApiVersion, Name, Namespace, TargetType, Description, Path, Summary, FileName, FileRow, EventTime FROM kubescore WHERE Namespace = ?`

	rows, err := r.DB.QueryContext(ctx, query, namespace)
	if err != nil {
		return nil, fmt.Errorf("error executing query: %v", err)
	}
	defer rows.Close()

	var kubeScores []*model.KubeScore
	for rows.Next() {
		var ks model.KubeScore
		if err := rows.Scan(&ks.ID, &ks.ClusterName, &ks.ObjectName, &ks.Kind, &ks.APIVersion, &ks.Name, &ks.Namespace, &ks.TargetType, &ks.Description, &ks.Path, &ks.Summary, &ks.FileName, &ks.FileRow, &ks.EventTime); err != nil {
			return nil, fmt.Errorf("error scanning row: %v", err)
		}
		kubeScores = append(kubeScores, &ks)
	}

	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("error iterating rows: %v", err)
	}

	return kubeScores, nil
}
func (r *Resolver) fetchResources(ctx context.Context, namespace string) ([]*model.Resource, error) {

	query := `SELECT ClusterName, Namespace, Kind, Resource, Age, EventTime FROM getall_resources WHERE Namespace = ?`

	rows, err := r.DB.QueryContext(ctx, query, namespace)
	if err != nil {
		return nil, fmt.Errorf("error executing query: %v", err)
	}
	defer rows.Close()

	var resources []*model.Resource
	for rows.Next() {
		var res model.Resource
		if err := rows.Scan(&res.ClusterName, &res.Namespace, &res.Kind, &res.Resource, &res.Age, &res.EventTime); err != nil {
			return nil, fmt.Errorf("error scanning row: %v", err)
		}
		resources = append(resources, &res)
	}

	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("error iterating rows: %v", err)
	}

	return resources, nil
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
